26  

Дано масив цілих чисел nums, відсортований у порядку не спадання , видаліть дублікати на місці так, щоб кожен унікальний елемент з’являвся лише один раз . Відносний порядок елементів має бути незмінним . Потім поверніть кількість унікальних елементів уnums .

Враховуйте кількість унікальних елементів для того nums, щоб kбути прийнятим, вам потрібно виконати такі дії:

Змініть масив numsтак, щоб перші kелементи numsмістили унікальні елементи в тому порядку, у якому вони були присутні numsспочатку. Решта елементів numsне важливі, а також розмір nums.
Повернення k.
Спеціальний суддя:

Суддя перевірить ваше рішення за допомогою такого коду:

int[] nums = [...]; // Вхідний масив 
int[] expectNums = [...]; // Очікувана відповідь правильної довжини 

int k = removeDuplicates(nums); // Викликає вашу реалізацію 

assert k == expectNums.length; 
for (int i = 0; i < k; i++) { 
    assert nums[i] == expectNums[i]; 
}
Якщо всі твердження прийнятні, ваше рішення буде прийнято .

 

приклад 1:

Вхідні дані: nums = [1,1,2]
 Вихідні дані: 2, nums = [1,2,_]
 Пояснення: ваша функція має повернути k = 2, причому перші два елементи nums дорівнюють 1 і 2 відповідно. 
Немає значення, що ви залишите за поверненим k (отже, це підкреслення).
приклад 2:

Вхід: nums = [0,0,1,1,1,2,2,3,3,4]
 Вихід: 5, nums = [0,1,2,3,4,_,_,_,_, _]
 Пояснення: ваша функція має повернути k = 5, причому перші п’ять елементів nums дорівнюють 0, 1, 2, 3 і 4 відповідно. 
Немає значення, що ви залишите за поверненим k (отже, це підкреслення).